# Сети, многопоточность

## IP

* Две версии протокола: IPv4 (4 байта на адрес), IPv6 (16 байт на адрес)
    * `127.0.0.1` --- localhost (это устройство)
* DNS -- сервис, который умеет по имени домена (`google.com`) получать его IP-адрес (+ какую-то еще информацию). Можно
  посмотреть на `nslookup`.
* После соединения устройства общаются при помощи небольших (2-64 Кб) пакетов, нет никаких гарантий, что пакет дошел.
* Чтобы кидаться пакетами удобно есть различные протоколы.
* Чтобы кидаться пакетами есть протокол для взаимодействия между локальными сетями -- NAT

## TCP

```
  client (initiates)           server (accepts)
┌───────────────────┐  bytes  ┌────────────────┐
│      ip:port      ├────────►│     ip:port    │
│95.161.246.38:65124│◄────────┤186.2.163.228:80│
└───────────────────┘  bytes  └────────────────┘
```

* Порт -- число от 1 до 65535. Для установления соединения на сервере и клиенте открывается специальная абстракция --
  сокет (пара `ip, port`).
* Заметим, что соединение определяется набором `откуда ip, откуда порт, куда ip, куда порт`.
* Для подключения к серверу НУЖНО знать его порт и адрес, а вот на клиенте порт обычно выбирается случайно.
* в TCP соединение **надежное** (пакеты не теряются, не дублируются).

## Вернемся к коду!

### Сервер

Используем `boost.Asio`, потому что в плюсах ничего встроенного нет, ибо под каждой системой свои реализации.

Смотрим `02-server.cpp` (блокирующий сервер):

1. Создаем `io_context` -- состояние для ввода-вывода, но нам побоку, потому что у нас все блокирующее.
2. Создаем `acceptor` -- Что-то вроде сокета.
3. Дальше создаем `tcp::iostream` -- ровно тот же `iostream`, как раньше, но для сокета.
    1. Внутри конструктора лямбда, которая создает сокет.
    2. метод `accept` возвращает сокет, где произошел коннект.
    3. После этого возвращает сокет, выводя какую-то информацию.

### Клиент

Смотрим `03-client.cpp`

* Здесь просто создаем сокет (пока без ацептора).
* Дальше при помощи `tcp::resolver.resolve`.
* После этого, просто собираем из этого `iostream`.

### Исключения

Нельзя включать исключения, они работать не будет (точнее будут, но программа будет падать из-за исключений в
деструкторе).

## Потоки

Используем `std::thread`. Конструктор --- функтор, который будет выполняться в новом потоке.

Есть `.join()` -- ждет конца потока + завершаем его, освобождая ресурсы.

В `std::thread` можно передавать аргументы:
если `int f(int a, int& b) {...} ... std::thread(worker, std::ref(a), b).join();`

В линуксе нужно компилировать с ключом `-pthread`.

## thread_local

Можно делать переменные, которые будут локальными для данного потока: `thread_local T name`.

Такие переменные могут быть локальными, глобальными.

## detach

Можно сделать `detach` -- сказать, что мы не отвечаем за поток и теперь OS отвечает за сбор мусора.

Заметим, что, если сделать `detach`, а потом обращаться к переменным из `main`: глобальным или статическим, то мы скорее
всего проиграем. Так как мы не можем гарантировать тот момент, что когда мы обращаемся к переменной, она еще не убита.

## Гонки

При одновременной записи в ресурсе, то порядок записи не определен. Причем это еще сложно дебажить.

А как с этим разбираться? Узнаете в следующей серии!