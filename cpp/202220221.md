**мне было супер вломас + неинтересно, поэтому конспект неоч :(**

# Trivially copyable

Посмотрим на такую структурку:

```c++
struct S {
    char c;
    int a = 10, b = 20;
};
```

Инты `a`, `b` у нас выравнены неправильно, поэтому код может ломаться от работы с такими переменными:

* при обращении `S.a` все будет хорошо, потому что мы знаем, что здесь все неочень и компилятор это обработает.
* При взятии ссылки ничего не понятно, потому что ссылка не знает ничего про свое происхождение. Поэтому тут
  возникает `UB`. Поэтому вы не можете делать `swap` :(

Категорически не хочется делать `#pragma pack` в структурах, в которых есть сложные типы. Например, с `std::vector`.

Причина в том, что вектор может быть не готов работать как невыравненная структура. Вторая причина заключается в том,
что непонятно зачем: `std::vector` скорее всего не trivially copyable, а значит это вообще не имеет смысла.

## standardLayout

Типы, предназначенные для взаимодействия с другими языками:

* запрещены виртуальные функции и наследование,
* В множественном наследовании без дублирования базы,
* Все поля объявлены в одной структуре и с одним уровнем доступа. Иначе бы компилятор мог крутить туда-сюда порядок
  полей.
* А если StandartLayout структура еще и triviallyCopyable, то она POD (Plain Old Data).

## немного про потоки

### `shared_ptr`

Копирование `shared_ptr` внутри потока потокобезопасное, а вот разыменовывание -- нет.

### `exception_ptr`

Хотим уметь ловить из `async` исключение и получать его из `get`. Для это придумали `std::exception_ptr`.

По факту это `shared_ptr<exception>`. Основное отличие в том, что можно использовать `std::current_exception` -- вернуть
текущее исключение (в `catch`) или `nullptr` иначе.

С `exception_ptr` можно делать `std::rethrow_exception` то есть кинуть снова исключение.

### Еще про TOC-TOU

Пусть у нас есть простой односвязный список и `set_next(node*)` и `get_next()`, которые потокобезопасные. Пока проблем
нет.

Теперь хотим сделать функцию `append_after`:

```c++
void append_after(list_node *x, int data) {
    x->set_next(new list_node(data, x->get_next()));
}
```

И все сломалось! Почему? А потому что у нас `append_after` плохой: у нас сначала может быть два `get`'а, а потом
два `set`'а и проиграем. Поэтому такую функцию надо сделать под мьютексом.

### placement new

Можно отделить аллокацию памяти и создание объекта:

```c++
alignas(alignof(Foo)) unsigned char data[sizeof(Foo)];
Foo *f = new Foo(data) Foo();
...
f->~Foo();
```

Можно еще вот так:
```c++
new (data) Foo();
Foo *f = reinterpet_cast<Foo*>(data);
```