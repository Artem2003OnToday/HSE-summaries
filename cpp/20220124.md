# Продолжение исключений

## Что не является

* Переполнение
* Деление на 0
* `assert(false)`
* Не хватило памяти вектору при создании -- `std::bad_alloc`, `vec[vec.size()]`, `vec.at()` -- `std::out_of_range`

## Гарантии исключений

Рассмотрим пример кода:

```c++
void do_something() {
    std::vector<int> vec(100'000'000'000);
    vec[vec.size() - 1] = 123;
}

void no_guarantee() {
    std::cout << "2+2=";
    int *data = new int[10];
    do_something();
    delete[] data;
    std::cout << "4\n";
}

void basic_guarantee_1() {
    std::cout << "2+2=\n";
    std::vector<int> data(10);
    do_something();
    std::cout << "4\n";
}

void basic_guarantee_2() {
    std::cout << "2+2=4\n";
    std::vector<int> data(10);
    do_something();
}

void strong_guarantee() {
    std::vector<int> data(10);
    do_something();
    std::cout << "2+2=4\n";
}

void noexcept_guarantee() noexcept {
    assert(std::cout.exceptions() == std::ios_base::goodbit);
    std::cout << "2+2=4\n";
}
```

* `no_guarantee` -- без гарантий (нет гарантий безопасности), при возникновении исключения завершает свое выполнение,
  поэтому при исключении может появиться UB, утечка памяти, нарушаются инварианты.
* `basic_guarantee1` -- базовые гарантии. При возникновении exception сохранились все инварианты (утечек памяти тоже не
  должно быть), но состояние могло измениться.
* `basic_guarantee2` -- теперь еще и вывод хороший.
* `strong_guarantee` -- Строгая гарантия. При возникновении исключения состояние программы не изменилось.
* `noexcept_guarantee` -- Гарантия отсутствия исключения. Исключений строго нет. Следующая строчка всегда выполняется.
  Отличается ключевым словом `noexcept`. Тут есть философский вопрос: считать ли вывод на экран состоянием программы?

```c++
int counter = 0;
void funny_basic_basic_guarantee1() {
    counter++;
    throw 0;
} // состояние изменилось, инвариант нет
```

## noexcept

Что будет, если функция `noexcept`, а внутри получилось исключение? Смотрим пример: `03-noexcept.cpp`. Там мы увидим,
что если внутри `noexcept` функции появилось исключение, которое просто экстренно убивает программу.

## Исключение в деструкторе

Смотри `04-dtor-noexcept.cpp`. При выкидывании исключения в деструкторе, пока летит другое исключение, тогда
получится `std::terminate`.

Вообще: деструктор НИКОГДА не может выкидывать `exception`, он помечен `noexcept` неявно. Но это в `C++11+`

В `C++03` `std::terminate` будет вызываться только при хотя бы двух исключениях.

## RAII

RAII -- Resource Acquisition Is Initialization (захват ресурса -- инициализация).

1. Конструктор устанавливает инвариант и забирает ресурсы. Выкидывает исключения, если не получилось. (обычно на это
   забивают)
2. Деструктор должен корректно освободить ресурсы. (Обычно подразумевается вот это).

Есть теоретический способ разделить исключения конструктора и все остальное:

```c++
struct already_handled {};
try {
    auto v1 = []() {
        try {
            return std::vector<int>(1'000'000);
            // return std::vector<int>(100'000'000'000);
        } catch (std::bad_alloc &) {
            std::cout << "caught bad_alloc from v1\n";
            throw already_handled();
        };
    }();
    foo(v1);  // now exceptions from foo() are not caught.
} catch (already_handled &) {
    // do nothing, already handled.
}
```

Но это все только в теории :)

## Исключения между TU

Исключения можно ловить даже если оно кинуто в другой TU. Пример: `07-between-tu`.

## Скорость

Примеры `10/11-speed*.cpp`. С `noexcept`/компилятор уверен, что исключения не будет, код работать +- столько же, сколько
и код без исключений.

А теперь попросим кинуть исключение и получим время работы в 1000 раз больше. Как? А потому что `sad path` и вообще все
плохо.

## Откуда вылетает ~~птичка~~ исключение?

Смотрим папочку `02-exceptions-everywhere`.

* `01-ctor.cpp`. Деструктор у `with_destructor<1> y(true)` не вызывается. Почему? Потому объект считается созданным
  после завершения конструктора.
* `02-array.cpp`. Префикс массива (что уже создали) при исключении чистится. А вот вектор **должен** так же работать, но
  гцц так не думает.
* `03-member.cpp`. Префикс удаляется.
* `04-member-list.cpp`. Префикс удаляется.
* `05-delegated.cpp`. Один конструктор уже завершился => объект существует. Значит вызываем деструктор.
* `05-base.cpp`. Если исключение в базовом классе, то все как раньше. Иначе же, будем вызываться деструктор базового
  класса.
* `11-args.cpp`. Аргументы функции создаются до входа в функцию, в строчке с вызовом функции.
* `12-return.cpp`. Исключения при возврате можно ловить! Все круто!
* `13/14-*.cpp`. В `return` можно ловить исключения, но если в `int f = func(0);` у нас в `=` могло произойти
  исключение, и мы можем потерять элемент.