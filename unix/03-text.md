# Работа с текстовыми данными

Почти все утилиты используются с текстовыми данными, поэтому сегодня будут регулярные выражения.

## История

В конце 1960-х Клини придумал теоретический язык для описания строк. Кен Томпсон добавил (часть) этого языка для поиска
в редактор QED. Из QED регулярные выражения перекочевали в ed -- стандартный текстовый редактор системы.

При этом существует несколько стандартов регулярок:

- Basic Regular Expressions (BRE), POSIX
- Extended Regular Expressions (ERE), POSIX
- Perl Compatible Regular Expressions (PCRE). Из Perl синтаксис перешел в Java, .NET, Python, Ruby, JavaScript и тд.

Пример: `ls *.txt`. Это не регулярное выражение.

В регулярных выражениях есть два типа символов: обычные символы (литералы) и метасимволы (wildcard), несущие какой-то
управляющий смысл.

Литералы: все символы, кроме `[]\^$.|?*+(){}`, либо они же, но с `\` в начале.

Метасимволы:

- `.` -- обозначает 1 любой символ: `st.n` **stand**dart, **stan**
- Символьные классы: `[A-Z]` -- любая заглавная латинская буква, `[a-d]` -- строчная буква от `a` до `d`, `[A-Za-z0-9]`
  -- Латинская буква или цифра. `[А-Яа-яЁё]` -- любая русская буква (не всегда, проблема русских кодировок).
    - Пример: `[*/+-]` и `[+-*/]` работают по разному: во втором классе минус будет воспринят как "все символы от + до *
      или /".
- `^`. Символ отрицания, идет в начале символьного класса `[^abc]` -- все символы, кроме `abc`.
- `|`. Перечисление -- разделяет допустимые варианты. Например, `gray|grey` -- или `gray` или `grey`. Можно ставить
  скобки: `gr(e|a)y`.
- `^` не в классе -- начало строки.
- `$` не в классе -- конец строки.
- `\b` -- граница слова `\ba\b` -- слова из буквы `a`.
- `\B` -- не граница слова.
- Квантификаторы:
    - `{n}` символ ровно `n` раз.
    - `{m, n}` -- символ от `m` до `n` раз.
    - `{m, }` от `m` и более раз.
    - `{,n}` не более `n` раз (в том числе 0).
    - `*` 0 и более.
    - `+` 1 и более.
    - `?` ноль и 1.
    - Можно использовать для логических блоков (скобок).

Пример: проверка MAC-адреса --- `^([0-9A-Fa-f]{2}:){5}[0-9A0Fa-f]{2}`.

После квантификаторов можно писать еще один символ:

- `*`, `?`, `+` -- жадный. Ищет максимально возможное включение регулярного выражения. По умолчанию.
- `*?`, `??`, `++` -- ленивый. Как можно раньше пытается перейти дальше по регулярке.
- `*+`, `?+`, `++` -- ревнивый.

Группировка -- скобки используются для задания приоритета операций. Можно получать группы при помощи `\<номергруппы>`

Можно выключить обратную связь `(?:шаблон)`. Делайте это всегда, когда вам не нужно получать группы.

Атомарная группировка. Никто не знает что это такое если бы мы знали что это такое.

ERE в сравнении с BRE:

- добавлены `? + |`
- исключено `\n`
- `(), {}` -- синтаксические элементы.

PCRE:

- ленивые, сверхжадные квантификаторы.
- Именованные группы связывания.
- Рекурсивные шаблоны
- Lookaheads и lookbehinds -- подсказки алгоритму поиска
- Сокращенные записи символьных классов: `\w`, `\W`, `\s`, `\S`, и тд.

## grep

В `ed` для любой правки нужно было ввести команду. Одной командой пользовались часто: `g/<regex>/p` -- найти и
напечатать строки, подходящие под регулярки. Получилась утилита `g/re/p` -- `grep`.

`grep 'regex' 'файл'`:

* `grep -E '^(bat|Bat|cat|Cat)' heroes.txt`
* `grep -i -E '^(bat|cat)' heroes.txt`

## sed

sed -- "Stream EDitor". Читает входной поток строка за строкой на лету, изменяя его в соответствии со скриптом.

Язык `sed` имеет всего около дюжины команд, но хитрости их применения достойны целой книги.

### Запуск

* `sed -e script [input-file]`. Задаем скрипт прямо через аргументы
* `sed -f script-file [input-file]`. Считываем команды из файла
* `sed [options] script [input-file]`. То же самое, что и 1, но не рекомендуется.

### Работа

`sed` построчно прочитывает весь вход один раз, преобразовывает их и выводит.

Имеет два буфера данных: `pattern space` -- основной (там храним строчку, в него применяем команды), `Hold Space` --
дополнительный (можно сюда скидывать данные, для хранения данных между строчками).

* `sed -e '='`. Пронумеровать все строчки.
* `sed -e 'd'`. Очистить `pattern space` + прочитать следующую строчку.
* `sed -e '2,4d'`. Удалить 2-4 строчки.
* `sed -e '/{/,/}/d'`. Ищем первую строчку, которая матчится регулярками (тут удаляется от `{` до `}`).
* `sed -e -r 's/@/at/'`. Изменить `@` на `at`. Команда `s` применяется к строчке ровно один раз. Если хотим применить ко
  всем вхождениям, то надо применить постфикс `g`: `s/@/ at /g`. `-r` -- включить `ERE`.
* `sed -r -e 's/[0-9]+:[0-9]+:[0-9]+/& UTC/'` `&` вставить найденный текст.
* `\1, \2, \3` -- группы связывания (как в PCRE).
* `a, i, c` вставить ниже текущей, вставить выше, вставить вместо.

Пример с Hold Space: `1!G;h;$!d` -- перевернуть файл:
* `1!G` -- для каждой строки, кроме первой, дописать содержимое `hold space` в конец `pattern space`
* `h` -- копирует содержимое `pattern space` в `hold space`
* `$!d` -- применяет `d` ко всем строкам, кроме последней.
