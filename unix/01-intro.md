# Обо всем и про UNIX

## Оргинфа

Это курс:

1. не про UNIX
2. неправильный, потому что в него впихнули все, что не влезло в основной курс

Материалы будут на [вики](https://wiki.compscicenter.ru/index.php/CSC_Wiki).

Отчетность состоит из ДЗ и КР. Блок -- меньше 60% от всех баллов (в том числе контрольных).

ДЗ могут быть обязательными и дополнительными. КР будут в количестве 2 штук. У каждой переписки будет 3 переписки:
написание, переписка, переписка в качестве экзамена.

Некоторые правила в индивидуальных случаях могут заменяться. Например, в прошьом году была возможность сделать задание,
которое заменяло КР.

Есть возможность получать некоторое небольшое количество доп. баллов за работу на занятии.

Длительность: не детерминирована, от пары до двух. Начало 10:20-10:30. Конец точно перед алгеброй.

Иногда будут практические занятия.

### Домашние задания

Сдаются в репозиторий, проверяются проверяторами.

## История UNIX

Зачем: чтобы понимать почему все так и почему мы не будем его изучать.

- 1960е: Multics (Multiplexed Information and Computing Service) (MIT, Bell Labs, GE) -- многопоточность, модульность,
  для мейнфреймов.
- 1969: Unics (UNIplexed Information and Computing System) (Ken Thompson, Dennis Ritchie) -- time-sharing system,
  иерархическая файловая система, процессы, файлы устройств, командная строка. При создании старались утянуть все
  хорошие вещи из Multics.
- 1971: Unix -- работа с текстом (форматирование, редактор), написана на ассемблере.
- 1973: 3 версия, переписан на языке C (все кроме ядра и I/O). Переписана была для того, чтобы систему можно было
  переносить на другие компьютеры (то есть портировать).
- 1975: 4-6 версии -- pipes.
- 1979: 7 версия, общий идеологический предок большинства существующих операционных систем.
- 1982: UNIX System III -- первая коммерческая версия от AT&T (стоимость ≈$5000). Начало борьбы с "незаконными"
  версиями.
- 1983: GNU (Richard Stallman, GNU is Not Unix) -- идея создания свободной UNIX с нуля, gcc.
- 1985: Free Software Foundation, GNU GPL -- если используете GNU GPL, то вы обязаны сохранять лицензию и предоставлять
  доступ к коду.
- Коммерческие системы продолжали развиваться. Движение было в сторону BSD-систем
  (откуда пришел, например, TCP/IP стек).
- 1987: Minix (Andrew S. Tanenbaum) предложил ядро системы.
- 1991: Linux (Linus Torvalds, Linux Is Not Unix) новое ядро, которое сообщество приняло. После этого появилась
  операционная система: GNU/Linux.

Линуксы отличаются тем, как мы собираем ядро (флаги компиляции, модули, компилятор). К ядру можно добавлять разные
утилиты: графические оболочки и тд.

Мы не будем изучать UNIX: настоящий UNIX сейчас -- это Solaris.

Но, в *NIX, например, Linux, есть все, что есть в UNIX. Поэтому мы будем изучать UNIX на примере Linux.

## Краткий обзор

### Терминология

- **Kernel** -- ядро, основная программа. Контролирует железо, CPU, память, диски и тд.
- **Shell** -- пользовательская оболочка -- программа, которая запускается каждый раз, когда пользователь подключается к
  серверу через терминал.
- **Терминал** -- устройство с экраном и клавиатурой: напечатанное передается на сервер, результаты вычисления на
  котором передаются на экране.
- В современном мире терминалы виртуальные. "Командная строка", интерпретатор -- shell, а программа для ввода --
  терминал.

### Директории

- Все есть файлы.
- Файлы размещаются в директориях.
- Директории складываются в иерархическую структуру.
- Можно добавлять или удалять любую директорию в/из дерева директорий.
- Корневая (_root_) директория "/". Root -- самый крутой пользователь.
- У каждого пользователя есть своя домашняя (_home_) директория.

### Стандартные директории

- `/bin` -- лежат "ярлыки" для запуска команд. Точно лежат системные утилиты.
- `/sbin` -- /bin, но только для рута.
- `/dev` -- все устройства (например, диски, DVD-ROM, устройства ввода)
- `/etc` -- различные конфигурационные файлы системы.
- `/home` -- папка для всех домашних директорий
- `/var` -- файлы, которые меняются часто + в которые можно писать
- `/tmp` -- временные файлы. После перезагрузки полностью очищается.
- `/usr` -- все установленные пакеты программ.
- `/proc` -- различная информация, которую ядро может сообщить пользователю.

### Введение в команды UNIX

**POSIX** -- Portable Operating System Interface for Unix --- стандарт, который описывают операционную систему. Внутри
этого стандарта есть раздел POSIX Shell.

Различные shell'ы:

* Bourne shell compatible: sh, ash, bash, dash, ksh, zsh.
* C Shell compatible: csh, tcsh
* Exotic: es (functional), psh (Perl). pysh (Python)

### Где взять Shell

* В линуксе/MacOS все уже есть.
* Можно поставить Cygwin - POSIX-прослойка для Windows
* Можно поставить Docker.
* Можно поставить VirtualBox
* Можно использовать WSL

### Docker

#### Мотивация

В некоторых домашках иногда можно угробить систему, докер удобен для проверки: если есть общий раз, то совпадут версии
библиотек, плюс точно гарантируется запускаемость.

#### Решение

**Docker** -- программное обеспечение для автоматизации развертывания и управления приложениями в среде виртуализации на
уровне операционной системы.

**Host OS** -- ваша операционная система.

**Гостевая ОС** -- операционная система, которая внутри виртуалки.

#### Понятия

* Образ (Image) -- некоторый шаблон окружения, доступный для чтения. Может содержать, например, Ubuntu.
* Для всего популярного уже есть образы на [Docker Hub](https://hub.docker.com)

#### Пример

Разберемся с

```bash
$ docker run -it ubuntu:16.04 bash
```

- docker -- команда,
- run -- команда внутри команды
- `-it` -- аргументы запуска (`i`, `t` -- два разных аргумента, `i` -- interactive, `t` -- запуск команды)
- `ubuntu` -- название образа
- `16.04` -- версия образа (мы используем 16.04, потому что эта версия есть практически везде)
- `bash` -- команда, исполняемая после инициализации образа.

Если образа локально нет, то он автоматически скачается с DockerHub'а.

После этого можно выполнить `cat /etc/lsb-release` (команда `cat` читает файл). Выведется инфа, по которой можно понять,
что у нас убунта с нужной версией.

Если после работы закрыть окошко, то может два варианта в зависимости от настроек докера:

1. Он умрет :(
2. Он останется крутиться внутри. Тогда `docker start` поможет вернуться в него (до перезагрузки).

#### Сохраняем состояние

Можно сделать снепшот текущего состояния при помощи `docker commit <container_name> <new_image_name>`.

После этого можно выполнить `docker image ls` чтобы посмотреть все образы.

#### Мост между хостом и контейнером

Можно сделать `docker run -v /host_workdir:/container_workdir -it docker_sb:latest bash`. После этого в `/host_workdir`
на хосте будет папка, в которую можно кидать файлы и они появятся в `/container_workdir` в контейнере.

#### Плюсы/минусы докера в сравнении в виртуалкой

Докер хорош для маленьких систем. Но вот если нам будет нужен монстр, то лучше нужна виртуальная машина.

### Домашнее задание

Поставить докер, запустить убунту. ДЗ проверяться не будет, но лучше это сделать.

Множество людей, не поставивших докер коррелирует с множеством людей с допсой.

### Примеры команды

* echo -- напечатать аргументы
* printf -- напечатать, но с форматом.
* read -- прочитать из стандартного потока

Общий вид команды: `<имя команды> <аргумент> <аргумент> <аргумент>...`. При этом есть особые аргументы: флаги.
Начинаются с "-". Например:

```shell
mkdir -p a # создать директории с названием "a"
mkdir -- -p a # создать директории с названиями "a", "-p"
# Но при этом в работе с файлами есть еще способ
mkdir ./-p # в текущей папке(./) создать директорию -p (аргумент не начинается с -!)
```

Флаги можно комбинировать: `ls -CF1` <=> `ls -C -F -1`. Но это соглашения, их никто не форсирует. 

   