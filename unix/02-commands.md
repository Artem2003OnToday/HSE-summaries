# Docker и его команды

Подготовимся к тому, что мы в следующий раз будем делать что-то серьезное.

На следующее занятие нужен ноутбук, будем интерактивная часть.

## Работа с файлами

* `cd` -- перемещение по директориям (change directory)
* `pwd` -- напечатать текущий каталог,
* `rm` -- удаление файлов (и каталогов),
* `cp` -- копирование файлов,
* `touch` -- создание файла (если файл есть, то просто изменяет время создания),
* `ls` -- список файлов,
* `more`, `less` -- интерактивный просмотр файлов,
* `head`, `tail` -- напечатать начало/конец файлов,
* `wc` -- посчитать что-то (слова, байты, строки) в файле,
* `sort` -- сортирует ввод как-то (или шаффлит),
* `tee` -- позволяет одновременно выводить ввод на экран + в файл,
* `find` -- команда с богатым синтаксисом, позволяющую искать файлы/каталоги + делать над ними действия,
* `locate` -- во всей системе по имени ищет файл,
* `grep` -- среди входных данных ищет вхождения регулярные выражения.

## Интерактив

Вопрос из зала:

Р: что будет если запускать `docker run -it ubuntu:16.04 bash` без `bash`

АМ: у каждого образа есть дефолтная команда, а `bash` в конце переопределяет команду запуска.

```shell
$ docker run -it ubuntu:16.04 bash
root@4ccef82f674b:/# 
^^^^ 
имя пользователя
     ^^^^^^^^^^^^
     container id
```

Заметим, что если бы мы были не рутом, то вместо решетки был бы `$`.

Итак, посмотрим команду `ls`:

```shell
root@4ccef82f674b:/# ls
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@4ccef82f674b:/# cd /etc/
root@4ccef82f674b:/etc# ls
X11                     binfmt.d        deluser.conf  gshadow    insserv         ld.so.conf     lsb-release     opt         rc.local  rc6.d        shadow       systemd
adduser.conf            cron.daily      dhcp          host.conf  insserv.conf    ld.so.conf.d   machine-id      os-release  rc0.d     rcS.d        shells       terminfo
alternatives            cron.weekly     dpkg          hostname   insserv.conf.d  legal          mke2fs.conf     pam.conf    rc1.d     resolv.conf  skel         timezone
apt                     dbus-1          environment   hosts      issue           libaudit.conf  modules-load.d  pam.d       rc2.d     rmt          subgid       tmpfiles.d
bash.bashrc             debconf.conf    fstab         init       issue.net       localtime      mtab            passwd      rc3.d     securetty    subuid       udev
bash_completion.d       debian_version  gai.conf      init.d     kernel          login.defs     networks        profile     rc4.d     security     sysctl.conf  update-motd.d
bindresvport.blacklist  default         group         inputrc    ld.so.cache     logrotate.d    nsswitch.conf   profile.d   rc5.d     selinux      sysctl.d     xdg
root@4ccef82f674b:/etc# less /etc/passwd 
bash: less: command not found
```

В винде мы бы плакали, но у нас чад линукс, поэтому мы не будем бегать по интернету, искать пакеты, мы воспользуемся
пакетным менеджером.

## apt

Дефолтным пакетным в убунте является `apt`. Посмотрим на его синтаксис:

* `apt update` -- Обновляет информацию об известных пакетах. Что? Все пакеты хранятся в репозиториях, и поэтому нам
  нужно знать какие же нам нужны пакеты.
* `apt install <пакет>` -- Установить пакетом.

## /etc/passwd

Посмотрели при помощи `less` на `/etc/passwd`. Что это за файл? Это файл с информацией о пользователях.

Первое, что мы видим -- это то, что пользователей много. Зачем? Чтобы можно было бы запускать сервисы от их имени, чтобы
если взломали сервис, то получили бы доступ к некоторым папкам, а не ко всей системе.

Второе -- числа,  `uid` (`user id`).

Третье, здесь нет пароля. Но файл называется `/etc/passwd`, по логике там должен храниться пароль. Да, раньше там
хранился хеш, но так как файл открыт для чтения, то это плохая идея.

## mc

Для маленьких девочек, которые не справились с консолью. Текстовый файловый менеджер. Мы его не любим.

## nano

Текстовый редактор, которым можно пользоваться, если вы не осилили `vim`. Ничего больше не сказать

## vim

ОЧЕНЬ КРУТОЙ ТЕКСТОВЫЙ РЕДАКТОР 10/10, но надо осилить...

Есть два режима, режим команд и режим текста.

Основные команды:

* ":wq" -- выйти, сохранив файл.
* ":!" -- выйти, не сохранив файл.
* "i" -- перейти в режим ввода. Esc -- кнопка, позволяющая вернуться в режим команд.

## Автодополнение

В многих Unix-like системах есть автодополнение по TAB. Причем, если автодополнение неоднозначно, то он ничего не
сделает, а еще одно нажатие таба покажет все варианты.

## Hotkeys

* Ctrl+D -- послать завершение ввода (EOF).
* Ctrl+C -- послать сигнал SIGINT, заканчивает процесс.
* Ctrl+Z -- послать процесс SIGTSTP.

## Код возврата

Утилиты в Linux'е написаны скорее всего либо на питоне, либо на C/C++.

И там, и там код возврата. Причем, если мы раньше знали, что 0 -- ок, а все остальное -- не ок, то сейчас будут понты:

- 0 if OK
- 1 if minor problems
- 2 if major problems.

&& -- ленивое И. Работает по коду возврата, || -- ленивое или.

## Потоки ввода-вовода

Есть три основных потока:

- stdin -- поток ввода,
- stdout -- поток вывода,
- stderr -- поток ошибок.

В шелле есть перенаправление потоков:

- `>` -- позволяет перенаправить поток вывода в файл
- `>>` -- дописывать в файл
- `<` -- читать из файла
- `2>` -- перенаправить поток ошибок
- `|` -- перенаправить поток вывода в поток ввода следующей команды. `command1 | command2`. Заметим, что `command1`
  работает параллельно с `command2`. При этом ВЕСЬ вывод `command1` попадет в ввод `command2`. При этом рассчитывать,
  что чтение происходит определенным образом нельзя.

## Аргументы командной строки

### Кавычки

- `'tex\t$'` -- текст передается как есть, без всяких escape, долларов...
- `"text\t$kek"` -- текст передается, но изменяется интерпретатором, например, при помощи escape последовательностей.

### Длинные и короткие флаги

У разных команд есть длинные и короткие флаги, например `cat -n file`, `cat --number file`. Еще можно объединять
короткие флаги: `rm -r -f <=> rm -rf`.

## man

Печатает информацию о программе: `man <name>`.

Поиск программы по названию `whatis <name>`.

Поиск программы по тексту `apropos <query>`. Можно задать секцию `apropos -s <section> sort`.

## Задачи
* Посчитать количество файлов с расширением `.txt`
* В файле `ip.txt` записан IP адрес. Пропинговать компьютер и записать результат в `res.txt`, а ошибки -- `err.txt`.
* Создать файл, хранящий в себе список процессов, которые начинаются на r.
* Напишите команду, которая копируют содержимое файла не используя дополнительный файл.