\Subsection{Группы вычетов и криптографические протоколы}
Главное отображение, которое нас интересует --- $p_k: \left(\Z / p\Z\right)^* \to \left(\Z / p\Z\right)^*: p_k(x) = x^k$.

Заметим, что если  $(p - 1,k)=1 \Rightarrow p_k$ --- биекция:  $p_k^{-1}(x) = x^l$, где  $l: kl = 1 \pmod{p-1}$.  $x\to x^k\to(x^k)^l = x^{kl} = x^1 = 1$. $x\to (x^l) \to (x^l)^k = x$.

А если $(p - 1, k) \neq 1$, то $p_k$ --- не биекция. Если  $p - 1$ =  $k \cdot s$ и  $g$ --- первообразный корень, то  $\ord g = p - 1$ и $(g^s)^k = 1$. Тогда  $1^k=1$ --- не инъекция.

Классический протокол шифровки: протокол с закрытым ключом (ключ --- способ шифровки / дешифровки).

Пусть Алиса(А) и Боб(B) хотят обмениваться информацией. Хотят придумать закрытый ключ путем пересылки сообщений. 

Протокол Диффи-Хеллмана: A и B хотят сгенерировать закрытый ключ $m \in \N$.
 \begin{enumerate}
     \item Придумывают большое число $p$.
     \item Придумывают  $a$ --- первообразный корень по модулю  $p$:  $\ord_p(\overline{a}) = p - 1$.
     \item A: берет  $x \in \Z$ (лучше $(x, p - 1) = 1$) и посылает $a^x \pmod p$.
     \item B: берет $y \in \Z$,  $a^y \mod p$ 
     \item A вычисляет $\left(a^x\right)^y = a^{yx} \mod p$.
     \item B: вычисляет $(a^y)^x = a^{xy} \mod p$.
\end{enumerate}

Чтобы взломать надо найти $x, y$. Если есть  $x$, то посчитать  $a^x$ просто, а вот наоборот --- сложно.

Получили ключ  $a^{xy}$.
\Subsection{Алгоритм RSA}
RSA --- Rivest, Shamir, Adleman.

RSA --- шифрование с открытым ключом:
\begin{enumerate}
    \item A: придумывает $p, q$ --- большие простые. Вычисляет  $\varphi(pq) = (p-1)(q-1)$.  $p, q, (p-1)(q-1)$ --- закрытая часть ключа. 
    \item Выбирает  $d: \in \Z$  $(d, p - 1) = (d, q - 1) = 1$.  $p, q, d$ --- закрытая часть.
    \item Открытый ключ $n = pq$ и  $e \in \Z: de \equiv \pmod{(p-1)(q-1)}$. Решение Л.Д.У.
    \item B: хочет послать сообщение ($x \in \Z, (x, n) = 1$) A: он посылает $x^e \pmod n$.
    \item  A: получает  $y=x^e$ и вычисляет  $y^d = (x^e)^d = x^{ed} = x^{k \cdot \varphi(n) + 1} = x \pmod{n}$.
\end{enumerate}

Устойчивость: чтобы взломать, надо знать $(p-1)(q-1)$, то нам надо просто знать $p, q$. Но мы не умеем делать это быстро.
\Subsection{Генерация простых, тесты на простоту}
 \begin{theorem}
     $\pi(n)$ --- количество простых на  $[1, n]$. Тогда  $\lim_{n \to +\infty} = \frac{\pi(n)}{\frac{n}{\ln n}} = 1$.
\end{theorem}
\begin{consequence}
   Случайное число на $1, n$ --- простое с вероятностью  $\frac{1}{\ln n}$ 
\end{consequence}

Способ генерации: возьмем $p_1, p_2,\ldots,p_k$ --- простые (небольшие). Попробуем $n = p_1^{a_1}p_2^{a_2}\ldots p_l^{a_k} + 1$, где $a_i$ --- произвольные степени. Получили Тест Люка.

\begin{theorem}[Тест Люка]
Пусть  $b \in \Z$, такое что  $b^{n-1}= 1 \pmod{n}$ и  $b^{\frac{n-1}{p_i}} \neq 1 \pmod{n}$. Тогда $b$ --- простое.
\end{theorem}
\begin{proof}
    $b^{n-1} = 1 \Rightarrow \ord_n(\overline{b_n})$ -- делитель  $n - 1$.

    $b^{\frac{n-1}{p_i}} \neq 1 \Rightarrow \ord_n(\overline{b_n})$ --- не делитель $\frac{n-1}{p_i}$ для любого $p_i$  $\Rightarrow \ord(\overline{b_n}) = n-1 \Rightarrow |(\Z / n\Z)^*| \ge n-1 \Rightarrow n$ --- простое.
\end{proof}
\begin{remark}
    $n$ --- простое,  $b$ --- подходит  $\iff b$ --- первообразные корень. Их $\varphi(n-1)$. Пусть $\varphi(n-1) > \frac{n - 1}{10}$, значит через к тестов будет вероятность проиграть $\left(\frac{9}{10}\right)^k$, что мало.
\end{remark}
\begin{remark}
    Числа Люка --- неоч для RSA: $n=pq, p, q$ --- числа Люка. Такие числа с большой вероятностью факторизуются: Выбираем  $a \in \Z$, дальше  $a\to a^2 \to (a^2)^3 \to \ldots$, то есть вычисляем $a^{k!} \pmod{n}$. Помним, что  $p - 1 = \prod p_i^{a_i}, q - 1 = \prod p_i^{b_i}$. 

    Рассмотрим  $K_p = \min \{a^{k!} \equiv 1 \pmod p  \mid k \in \N \}$.  

    $k_p, k_q$ - не велики. Действительно:  $k_p \divby p - 1 = \prod p_i^{a_i}$, а $p_i$ --- довольно маленькие.
    
    Скорее всего $k_p \neq k_q$. Не умаляя общности считаем  $k_p < k_q$, тогда  $(a^{k_p!}, n) = p$. 
\end{remark}
\slashn
Тест Ферма: $n \in \N, a \in [1,\ldots,n-1]$. Если $a^{n-1} \not \equiv 1 \pmod{n}$, значит  $n$ --- составное. 
 \begin{definition}
     Если $n$ --- составное, но  $a^{n-1} \equiv 1 \pmod{n}$, то  $a$ --- свидетель простоты.
\end{definition}
\slashn
Если $n$ --- составное, то или свидетелей  $\le \frac{\varphi(n)}{2} \le \frac{n-1}{2}$, или любое взаимно простое с $a$ является свидетелем простоты. Свидетели образуют подгруппу, а значит либо это вся группа,либо там $\le \frac{\varphi(n)}{2}$ элементов. 

Пусть там меньше половины, тогда после $k$ итераций вероятность проиграть  $\frac{1}{2^k}$, что довольно хорошо.

Тест Рабина-Миллера. Пусть $n-1 = 2^s \cdot m$. Тогда, если  $n$ --- простое, то  $x^2 \equiv 1 \pmod{n} \Rightarrow x = \pm 1 \pmod{n}$. Тогда берем  $a \in (\Z / n \Z)^*$. Считает  $a^m, (a^m)^2, \ldots, (a^m)^{2^s}$. Так как $n$ --- простое  $\Rightarrow$ или $a^m = 1$, или есть  $-1$, а потом 1. 

Условие Миллера-Рабина работает для  $\forall a \in [1..\sqrt[7]{n}]$ или  $\in [1..\log^2 n]$, если верим в гипотезу Римана. 

Но Рабин заметил, что вероятность ошибиться для составного $\frac{\varphi(n)}{4}$ 

