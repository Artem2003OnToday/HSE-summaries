\Subsection{Полезные ссылки}
\begin{itemize}
\item \href{https://learngitbranching.js.org/}{Штучка для изучения веток}
\end{itemize}
\Subsection{Клонирование репозитория}.
Для этого используется команда \texttt{git clone <откуда> <локальная папка>}.

После клонирования в папке появится репозиторий и папка \texttt{.git}, в которой хранится информация про версии.
\Subsection{История}.
Можно посмотреть историю коммитов, для этого есть команда \texttt{git log}.
\Subsection{Ветки}
Одна из главных возможностей гита --- ветки. Они позволяют независимо изменять код. При этом сам гит умеет делать мердж, причем довольно умно. 

На гитхабе есть фишка --- pull request. Это говорит мол: "Посмотрите на мои изменения, и если все ок, померджите в ветку". 

На самом деле ветка --- указатель на какой-то репозиторий. 

Для смены между ветками \texttt{git swith <ветка>}. При этом, если есть изменения, то нужно сначала будет с ними разобраться. Есть ключ \texttt{-c}.
\Subsection{Ненужные файлы}
Некоторые конвенции:
\begin{itemize}
    \item Мы не сохраняем исполняемые файлы, потому что они бесполезны и занимают лишнее место.
    \item По той же причине нельзя коммитить всякие файлы настройки IDE / log'и / временные файлы.
\end{itemize}

Как же не забыть не добавить эти файлы? Есть несколько способов:
\begin{itemize}
    \item \texttt{.gitgnore}. Файл, который нужно коммитить, но он работает на все папки на уровни ниже, чем он.
    \item \texttt{.git/info/exclude}. Не нужно коммитить, работает на весь репозиторий. 
\end{itemize}

\Subsection{Коммит}
После модификации мы увидим файлы в \texttt{git status}. После этого можно добавить файлы в новый коммит \texttt{git add <файл>} (либо \texttt{git restore <файл>} для возращения). После этого нужно сделать \texttt{git commit} и откроется текстовый редактор,в котором надо просто ввести комментарий. После этого вы сделали коммит.

Чтобы посмотреть изменения можно ввести \texttt{git diff}.

Можно писать \texttt{git add .} --- добавить все файлы в папке. При этом будет кукож, если не настроен \texttt{.gitgnore}. Но есть ключ \texttt{-u}, которой позволяет добавить только измененные файлы.

\Subsection{Идешь в душ, делай пуш}
После коммита обновление на сервере не произойдет. Для того чтобы протолкнуть изменения на сервер нужно ввести  \texttt{git push origin <ветка>}. 
 
\Subsection{Синхронизация}

Как сделать обратную операцию: принять изменения от сервера? Есть \texttt{git pull}, но он опасный как \texttt{<censored>}, поэтому используем \texttt{git fetch}.

Проблема: при фетче может произойти конфликт. Можно замерджиться: там просто удалить ненужные строчки. После этого надо сделать коммит с мерджем. 

\Subsection{Уничтожаем улики}

Можно откатить коммит, причем откатить из всей истории при помощи \texttt{git reset --hard <commit>}. Важно, что это не удалит сам коммит, просто удалит его из ветки.

После этого мы не сможем запушить, потому что мы находимся сзади \texttt{upstream'а}. Ну, сила есть --- ума не надо, запушим силой: \texttt{git push --force-with-lease}.

\Subsection{Устраиваем шоу}

Можно посмотреть на изменения в коммите командой \texttt{git show <коммит>}, а можно и просто файл \texttt{git show <коммит> два минуса <файл>}

