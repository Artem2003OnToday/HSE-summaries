\Subsection{Как думать над задачей.}
\begin{enumerate}
    \item Неформальная задача. Например: написать ВКонтакте. Это это уже общение с заказчиком / маркетинг. 
    \item Формальное условия задачи (на контестах/ДЗ обычно это первое). Также у вас есть примеры, но вы должны их уметь придумывать сами.
    \item Идея решения. Как понять, что она есть: умеете рисовать как код работает на примерах. 
    \item Декомпозиция кода (контракт --- соглашение между кусочками). То есть разбиение кода на более мелкие участки. Зачем это нужно? Это помогает удобно думать про задачу, думать отдельно про переменные/тестирование. Удобно, когда мало связей. Как понять, что декомпозиция верна: для каждого <<квадратика>> понимать как он работает на примере. \textit{Здесь бы схемку сделать}
    \item Инвариант (микроархитектура). Условия внутри какого-то кусочка кода, например в каком-то форе \texttt{a} должна быть четной.
    \item Код. 
\end{enumerate}

\Subsection{Пример задачи. cd и pwd}
Рассмотрим пример задачи: хотим написать эмулятор консоли, которая умеет выполнять две команды: \texttt{pwd} --- вывести текущую папку и \texttt{cd} --- перейти по пути. Два типа пути: абсолютные ~-- $/\ldots$ и $a / b / c\ldots$.

Стандартная олимпиадная задача, поэтому есть две стандартные части: ввод и \xout{вывод}. Далее из ввода есть \texttt{cur\_d, init(), do\_cd(string a), do\_pwd()}, а \texttt{do\_cd(string a)} вызывает \texttt{do\_cd\_a(...)} и \texttt{do\_cd\_r(...)}.

\begin{lstlisting}
init()
    cur_d = "/"

do_cd_a(path):
    cur_d = path
do_cd_r(path):
    while path.startswith("../"):
        path.erase(0, 3)
        last_slash = 0
        for i in 0..cur_d:
            if cur_d[i] == "/"
                last_slash = i
        cur_d.erase(last_lash, cur_d.len);
    cur_d += path
\end{lstlisting}

Проблема: код не работает. Проблема с тем, где могут стоять слеши, туда-сюда, в рот наоборот. Ну, бахним инвариант: путь начинается на $/$ и кончается на него же. Еще и код перехода назад работает за $\mathcal{O}(n^2)$. Двоеточия могут быть в абсолютном пути, может быть просто \texttt{cd .}. \texttt{cd ..} из \texttt{/}. Имя папки заканчивается на точку.

Пусть теперь папка --- \texttt{vector<string>}. Инвариант: внутри не хранятся ".", "..", ".", "/", "". По-хорошему, надо сделать функцию, которая постоянно проверяет корректность вектора. Это удобно при отладке.

Теперь сотрем весь старый код. Потребуется новый кусок кода ~-- \texttt{split(string)} -> \texttt{vector<string>}.

\begin{lstlisting}
init()
    cur_d = {}
do_cd_a(path)
    cur_d = 
do_cd_r(path)
    ...
\end{lstlisting}

Проблемы лучше искать заранее: исправлять код, который еще не написан проще. \href{http://blog.algoprog.ru/special-cases/}{Лучше думать про общее, чем про частное}.

\Subsection{Как меньше лажать внутри кода}

\begin{itemize}
    \item Название переменной. Название переменной должно показывать, что в нем лежит. Пример: \texttt{tmp} --- плохое название переменной. Потому что, да, она может быть временной, но непонятно что в ней лежит и как она будет использоваться.
    \item Плохое название в контексте. Например, \texttt{m} --- может быть норм, а вот еще и \texttt{mm} --- это кринж. Вообще использовать две переменные, названия которых являются префиксом/подстрокой другой --- кринжайший кринж. \href{http://blog.algoprog.ru/init-not-clear}{Хорошая статья на эту тему}.
\end{itemize}

\Subsection{Исправление багов}

Баг --- отклонение от ожиданий.

Если вы знаете баг, то найдите тест, на котором этот тест не работает, запомните его и исправьте баг, спустившись вверх по лестнице. 

Виды тестов:
\begin{enumerate}
    \item Примеры. 
    \item Простые/разные/общие. Программа умеет делать все виды ходов/все виды операций. То есть проверить все ветки.
    \item Минимальные/максимальные/граничные. Минимальные/максимальные по вводу/ответу/количеству действий. Короче минимизируем/максимизируем/ставим в граничные точки все возможные переменные во всех комбинациях. Есть исследование, которое говорит, что так находится сильно больше ошибок.
    \item Красивые тесты: строка Туи-Морса, симметричный граф, полный граф, строка из буквы "a".
    \item Случайные тесты.
    \item Регрессионные тесты. Тесты на баги, которые вы уже нашли (см. выше).
    \item Все возможные тест (если возможно).
    \item Как бы регрессионные тесты. Тест, если бы в строк $x$ был баг. 
\end{enumerate}

Но если не запускать решение на тестах, то это бесполезно.
Есть несколько методики тестирования:
\begin{itemize}
    \item Мультитест. Это когда решение на вход принимает несколько тестов и выполняет их тест за тестом. 
    \item Unit-тестирование. Это когда тестируются кусочки отдельно, что удобно, когда программа не работает целиком, то вы хотя бы уверены в том, что этот кусок работает.
    \item Stress-тестирование. Это когда решение запускается на множестве случайных тестов и сравнивается с медленным решением/чекером.
\end{itemize}


