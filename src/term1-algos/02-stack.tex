\lstset{language=c++}
\Subsection{Ликбез по плюсам}
Мне было вломас, сорян-борян (я контест закрывал).
\Subsection{Время}
\begin{itemize}
    \item \texttt{sqrt, pow, sin/cos, log} --- медленные функции.
    \item \texttt{cin/cout} --- довольно медленный ввод. Самый быстрый --- \texttt{fread/fwrite}. Быстрый ввод-вывод реализован в \texttt{optimization.h}. 
    \item Работа с памятью. \texttt{vector} и массивы работают за $\pm$одинаковое время (разница в 1\% чувствуется при очень больших $n$, но это только если тупо создания). Проблема, если выделяется/освобождается большое количество маленьких векторов.
    \item Доступ к памяти. Кеш. Есть несколько уровней памяти: регистры, кеш \texttt{L1}, кеш \texttt{L2}, кеш \texttt{L3}, ОЗУ, HDD. Каждый уровень работает в 2--10 раз больше (HDD раз в 100). Поэтому стоит делать последовательный доступ к элементам, а не случайный. Все из-за подгрузки в кеш. 
    \item Деление и взятие по модулю. 
    \item Рекурсия. Вход в рекурсия не тривиальная операция: нужно переложить регистры, чето-еще  чето-еще\ldots.
\end{itemize}
А теперь быстрые операции:
\begin{itemize}
    \item Операции с \texttt{char}, \texttt{int}. Все работает из-за векторизации: процессор умеет складывает сразу несколько чисел, которые не пересекаются. 
\end{itemize}
\Subsection{Сумма на отрезке}
Дан массив, поступают запросы $\left[l, r\right]$ --- сумма на отрезке  $l, r$. Запросов  $q$.
Решения:
\begin{enumerate}
    \item Тупое решение $\mathcal{O}(n \cdot q)$.
    \item Префиксные суммы. Насчитаем массив \texttt{F[i]} --- сумма на префиксе длины $i$. Тогда запрос:  \texttt{F[r] - F[l]}. Работает за $\mathcal{O}(n + q)$.
\end{enumerate}
\Subsection{Массив и вектор}
Массив --- просто набор чисел, а вектор еще умеет динамически расширяться (добавляться в конец). Есть \texttt{init(n), get(i), set(i, x)}. Все работает за  $\mathcal{O}$.

Простое решение: каждый раз перевыделять память. Работает за $\Theta(n^2)$.

Нормальное решение будем выделять  $2n$ операций. Теперь добавление в конец работает за  $\mathcal{O}(1)$, если размер меньше, чем аллоцированный размер. Иначе переаллоцируем на $2n$. В среднем работает за  $\mathcal{O}(1)$.
\Subsection{Список}

Для каждого элемента списка хранится два указателя: голова (\texttt{HEAD}) и хвост (\texttt{TAIL}). Ну и у самого списка есть и то, и другое.
Можно подцепить к началу и к концу. Удаление из начала из конца.

Можно добавлять после $i$ой позиции. Для этого его надо сначала найти.

\Subsection{Стек}
Добавление в конец, убирание из конца. Реализация на массиве: просто поддерживаем конец.
\Subsection{Очередь}
Добавление в конец, убирание из начала. Можно реализовать на односвязном списке. Можно на массиве, поддерживая два указателя: конец и начало.
\Subsection{Дек}
Добавление в конец/начало, взять из начала/конца. 
Можно реализовать так же, как и вектор, просто теперь выделять не только в конце, но и перед. А можно просто двусвязный список.
Преимущества массива: быстрота: кеш, меньше памяти. Преимущества списка: точная $\mathcal{O}(1)$.
\Subsection{Стек с минимумом}
Просто теперь будет хранить не просто число $x$, но и  $(x, \texttt{min}(x, \texttt{stack.head()})$.
\Subsection{Очередь с минимумом}
Реализуем на двух стеках с минимумом: добавляем в первый список. Теперь если надо вытащить, то проверяем сначала второй стек, если он пустой, то сразу переложим весь первый стек во второй. То есть перевернем первый стек. Минимум --- минимум на двух стеках. Каждый элемент переживет 4 операции: добавление в 1 стек, удаление из 1, добавление во 2 стек, удавление из второго стека. На каждый элемент  $\mathcal{O}(1)$ операций.
